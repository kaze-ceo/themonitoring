# Управление и мониторинг инфраструктуры

-----------ACTUAL VERSION (1.0.0а)-------------

Техническая документация:

# ОСНОВНАЯ ИНФОРМАЦИЯ

Справочники:
**Литература**
Перечень печатных и электронных материалов, используемых в разных подразделениях (учебники, методички, нормативные акты и т.д.).
**ЛитератураПрисоединенныеФайлы**
Скан-копии, документы, электронные версии, прикрепленные к элементам литературы.
**Сотрудники**
Работники префектуры и её объектов: преподаватели, технический персонал, администраторы и т.п.
**Клиенты**
Граждане, взаимодействующие с учреждениями (записываются на приём, получают услуги, используют литературу/оборудование).
**Оборудование**
Учёт всех технических средств: ПК, принтеры, терминалы, камеры видеонаблюдения и др.
**Авторы**
Авторы материалов, используемых в документации, методиках, обучающих программах и пр.
**ОбъектыПрисоединенныеФайлы**
Файлы, прикрепленные к различным объектам системы (например, планы зданий, договоры, акты).
**ОбъектыПрефектуры**
Реестровый список всех зданий и подразделений префектуры (школы, МФЦ, ГАИ, ЦОПы, медпункты и т. д.).
**ДосьеУчеников**
Персональные досье учащихся или участников образовательных программ внутри префектуры.
**Преподаватели**
Специализированный список преподавательского состава (может быть отдельным от общего справочника "Сотрудники").

Документы:
**ВыдачаЛитературы**
Учёт выдачи материалов (например, в методических центрах или учебных классах объектов префектуры).
**ВозвратЛитературы**
Фиксация возврата ранее выданных материалов.
**ПоступлениеЛитературы**
Приход новых печатных или электронных материалов в учреждения префектуры.
**СписаниеЛитературы**
Списание устаревших, испорченных или потерянных материалов.
**ИспользованиеПК**
Учёт использования компьютерных рабочих мест в различных учреждениях (бронирование, распределение по сменам).
**ЗаписиНаПриём**
Запись клиентов на личные встречи: в МФЦ, образовательных учреждениях, медкабинетах и т. д.
**ЗаписиВГАИ**
Запись на процедуры, связанные с автоуслугами: сдача экзаменов, оформление документов и т. п.
**ЗаписиВМФЦ**
Запись граждан в многофункциональные центры для получения государственных и муниципальных услуг.
**ПоступлениеОборудования**
Учёт поступившего оборудования в объекты префектуры.
**ЛистОценок**
Оценочные листы учащихся в образовательных учреждениях (школах, курсах и пр.).
**ВведениеОбъекта**
Документ ввода нового объекта префектуры в эксплуатацию (новое здание, помещение, участок и т. д.).

Журналы документов - Обеспечивают удобный просмотр, фильтрацию и контроль всех созданных документов.

Перечисления:
**СтатусВыдачиЛитературы**
Статусы — выдано, возвращено, просрочено, утеряно и т.п.
**ЖанрыПроизведений**
Жанровая классификация материалов (учебная, справочная, художественная, нормативная и пр.).
**СегментыЛитературы**
Категории литературы: школьная, профессиональная, административная и др.
**ТипыОборудования**
Классификация техники по типам: ноутбук, терминал, сервер, периферия.
**ТипыОбъектовПрефектуры**
Классификация зданий и подразделений: школа, центр обслуживания, МФЦ, ГАИ, архив и т.д.

Отчеты:
**ДвиженияПоКлиентам**
Действия клиентов в системе: записи, обращения, использование ресурсов и т. д.
**ПоставкиСписанияЛитературы**
Статистика по приходу и списанию литературы по подразделениям.
**АктуальныеСегментыИЖанрыПроизведений**
Какие виды материалов наиболее востребованы на текущий момент.
**ЗаписиНаПрием / ВГАИ / ВМФЦ**
Аналитика по количеству и статусу записей в соответствующие учреждения.

Регистры накопления:
**ПриходРасходНовойЛитературы**
Движения по поступлению и списанию материалов по подразделениям.
**ВыдачаВозвратАктуальнойЛитературы**
Учет по текущему обороту литературы между клиентами и учреждениями.
**СтатусыИспользованияПК**
Фиксация использования компьютерных рабочих мест, их доступность, бронирование и загрузка.
**ЗаписиВБольницы**
Учёт записей граждан в медкабинеты, прививочные пункты, медосмотры и т. д.
**ЗаписиВГАИ / ВМФЦ**
Подробная информация по движениям записи в соответствующие госструктуры.
**ПоступленияОборудования**
Сведения об остатках и новых поставках техники в подразделения.

------------------========--------------------

**Работа с регистрами накопления**

Классическая методика записи данных в регистры накопления

В документах используется стандартный механизм записи данных в регистры сведений через таблицу движений (когда ты привязываешь регистратор/документ к регистру накопления). Этот механизм настраивается в конфигураторе через свойства документа — на вкладке "Движения" указывается, в какие регистры и по каким правилам записываются данные.
Сам код записи в регистры автоматически формируется при проведении документа на основании этих настроек.

**Обработка Веб-страниц или Модуль быстрого доступа к ресурсам**

Процедуры вызываются на клиенте и предназначена для открытия сайтов через встроенную обработку. В объекте устанавливается признак выбранного действия (к примеру "ГАИ" и URL "https://госавтоинспекция.рф"). Далее выбранное значение записывается в объект, создаётся структура параметров с этим адресом и оповещение "Реадресация", которое, обрабатывается внутри формы. Затем открывается форма обработки Обработка.ДоступКСайтам.Форма.Форма, куда передаётся URL (Параметры.ВебСтраница. По сути после закрытия формы выбранное значение сохраняется в реквизит и при открытии формы с веб-страницей уже автоматически тянется нужный URL).

**Обработка реадресация** 

Обычная отдельная обработка чтоб удобнее было заниматься навигацией (тоже покликаешь поймешь, работает в паре с управлением модулями)

**Обработка управление модулями**

Тут, думаю, всё предельно ясно, обычная реадресация, при нажатии кнопки открывает другую форму (работает примерно по тому же принципу что и предыдущая, но вместо URL перенаправляет на нужные формы в 1С)

**Обработка управление префектурами**

Тут частично механизм из Веб-страниц (поймешь при нажатии) и динамические списки (по сути те же самые запросы как в отчетах просто в реальном времени, чтоб посмотреть какой там код открываешь вот здесь (ПКМ по динамическому списку -> Свойства -> Настройки списка)

<img width="1151" alt="Снимок экрана 2025-06-06 в 03 49 22" src="https://github.com/user-attachments/assets/736f1b50-d51d-4db8-8c91-ef18a0b9246d"/>

**Работа с картой и маршрутами**

Вот тут самое интересное, пытался объяснить вместе с нейросетью и гайдами на ютубе, думаю если спросят - ужать это ты сможешь. 

//ПриСозданииНаСервере

Когда форма создаётся на сервере, вызывается процедура ИнициализироватьКарту(), которая подгружает HTML-шаблон карты и маркер, заменяет путь к изображению маркера на встроенные base64-данные и передаёт этот HTML в поле ПолеHTML, чтобы отобразить карту на форме.

//ПолеHTMLПриНажатии

При нажатии на карту (на HTML-элемент ПолеHTML), вызывается JS-функция getLastMarkerLocation(), которая возвращает координаты последнего щелчка. Если координаты получены, создаётся новая точка маршрута в структуре ТочкиМаршрута и сохраняется широта и долгота из полученных данных. То есть, при клике на карту ставится точка маршрута.

//ПостроитьМаршрут

Запускает JS-функцию buildRoute() внутри HTML-документа карты. Эта функция рассчитывает маршрут по уже добавленным точкам и отображает его на карте.

//ПолучитьИнформациюОМаршруте

Получает информацию о построенном маршруте из браузера через getRouteInfo(). Данные приходят в виде JSON. Затем вызывается процедура ПрочитатьИнформациюОМаршрутеИзJSON(), которая парсит JSON, достаёт общее время и длину маршрута, а также список пошаговых инструкций (дороги и тексты) и заполняет соответствующую структуру Инструкции.

//ОчиститьМаршрут

Полностью очищает текущий маршрут: удаляет точки маршрута (ТочкиМаршрута.Очистить()), пошаговые инструкции (Инструкции.Очистить()), обнуляет значения времени и расстояния. В интерфейсе удаляет маркеры и сам маршрут с карты через JS-функции removeAllMarkers() и removeRouting().

//ИнициализироватьКарту

На сервере загружается HTML-шаблон карты и картинка маркера. Изображение маркера кодируется в base64 с помощью ДвоичныеДанныеВBase64, заменяется путь к marker.png на встроенные base64-данные, и результат сохраняется в ПолеHTML, чтобы отобразить карту с нужным маркером прямо в форме без обращения к внешнему файлу.

//ДвоичныеДанныеВBase64

Преобразует бинарные данные изображения в строку base64 и очищает её от символов переноса строки, чтобы можно было безопасно вставить в HTML.

//ПрочитатьИнформациюОМаршрутеИзJSON

Разбирает JSON-строку с маршрутом, достаёт из неё общее время и расстояние, очищает список инструкций и заново его заполняет. Каждая инструкция содержит название улицы и текст подсказки.

//ПолучитьЗначениеИзJSON

Создаёт объект ЧтениеJSON, устанавливает в него входную строку JSON и вызывает встроенную функцию ПрочитатьJSON(), которая возвращает структуру данных.

       **А тут уже JS играется**

Сам JS-код вместе с HTML находится в Макетах. Код лежит ТОЛЬКО в шаблоне карты, двоичные данные нужны для записи координат точек:

- Шаблон карты (отрисовка самой карты)

  Инициализация карты:
const map = L.map("map", { attributionControl: false }).setView(
  [52.0317, 113.501],
  13
);
Создает карту с центром на координатах [52.0317, 113.501], масштаб 13 (думаю поправлю на Москву, а то чет я хуйню написал и у нас там нихуёвая Чита).

Добавление тайлов (плиток):
const tiles = L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 19,
}).addTo(map);
Загружает OpenStreetMap-плитки как подложку карты (по сути реально отображает тайлы благодаря Leaflet).

Маркеры и маршруты
Переменные:

let routingControl;
let markers = [];
let distance = 0;
let time = 0;
let instructions;
routingControl — объект маршрута.
markers — список маркеров.
distance, time, instructions — информация о маршруте.
Иконка маркера:

const markerIcon = new L.DivIcon({
  className: "marker",
  html: `<img src="marker.png" style="width:20px; height: 20px"/>`,
  iconSize: [35, 35],
});
Создает кастомный маркер в виде иконки с marker.png (если хочешь поиграться - попробуй сменить).

Обработка клика по карте:
map.on("click", onMapClick);

function onMapClick(e) {
  addMarker(e.latlng);
}
Добавляет обработчик на клик по карте, вызывающий addMarker (отвечает за появление маркеров на мапе).

Функция добавления маркера:
function addMarker(latlng) {
  if (routingControl) return; // Если уже построен маршрут — не добавлять
  const marker = L.marker(latlng, { icon: markerIcon }).addTo(map);
  map.panTo(marker.getLatLng()); // Центрировать карту на маркере
  markers.push(marker);
}
Построение маршрута:
function buildRoute() {
  routingControl = L.Routing.control({
    waypoints: markers.map((marker) => marker.getLatLng()),
    routeWhileDragging: true,
    createMarker: function () {
      return null; // Не создавать стандартные маркеры
    },
    language: "ru",
    lineOptions: {
      styles: [{ color: "#5158bb", opacity: 1, weight: 5 }],
    },
  }).addTo(map);

  routingControl.on("routesfound", function (e) {
    distance = e.routes[0].summary.totalDistance;
    time = e.routes[0].summary.totalTime;
    instructions = e.routes[0].instructions;
  });
}
Строит маршрут между маркерами.
Сохраняет:
distance — расстояние в метрах.
time — время в секундах.
instructions — массив текстовых шагов маршрута.
Получение последнего маркера (при нажатии когда формируешь маршрут):
function getLastMarkerLocation() {
  if (markers.length === 0) return null;
  const latlng = markers[markers.length - 1].getLatLng();
  return [latlng.lat, latlng.lng];
}
Получение JSON-информации о маршруте:
function getRouteInfo() {
  return JSON.stringify({
    distance,
    time,
    instructions,
  });
}
Удаление маршрута:
function removeRouting() {
  if (routingControl) {
    map.removeControl(routingControl);
    routingControl = undefined;
    distance = 0;
    time = 0;
    instructions = undefined;
  }
}
Удаление всех маркеров:
function removeAllMarkers() {
  for (i = 0; i < markers.length; i++) {
    map.removeLayer(markers[i]);
  }
  markers = [];
}

# НОВЫЕ КАРТЫ В ПАРЕ С Yandex API

Код всё там же

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Карта Яндекс для 1С</title>

Установка кодировки и заголовка страницы.

  <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU" type="text/javascript"></script>

Подключаем Яндекс.Карты JS API версии 2.1 на русском языке.

  <style>
    html, body, #map {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: white;
      padding: 5px;
      border-radius: 5px;
    }
  </style>

Устанавливаем стили, чтобы карта занимала всё окно.
Панель с кнопками (#controls) — поверх карты, закреплена в левом верхнем углу.

<body>
  <div id="controls">
    <button onclick="downloadPlacemarks()">💾 Сохранить точки</button>
    <input type="file" id="fileInput" accept=".json" onchange="loadPlacemarks()" />
  </div>
  <div id="map"></div>

Интерфейс управления:


Кнопка "Сохранить точки" — вызывает функцию downloadPlacemarks().
Поле выбора файла — при выборе файла вызывается loadPlacemarks().
Ниже — контейнер под карту с id="map".

  <script>
    let map, placemarks = [];

Объявляем переменные:

map — объект карты
placemarks — массив меток, которые мы добавим
    ymaps.ready(function () {
Ожидаем, пока Яндекс.Карты полностью загрузятся.

      map = new ymaps.Map("map", {
        center: [55.76, 37.64],
        zoom: 10,
        controls: ["zoomControl"]
      });

Создаём карту внутри контейнера #map

Центр: Москва
Зум: 10

Добавляем панель масштабирования
      // Загрузка из localStorage
      const saved = localStorage.getItem("placemarks");
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          parsed.forEach(item => createPlacemark(item.coords, item.label));
        } catch (e) {
          console.error("Ошибка при загрузке точек:", e);
        }
      }

При запуске:

Пытаемся загрузить сохранённые метки из localStorage
Если есть, создаём метки на карте через createPlacemark
      // Левая кнопка — добавить метку
      map.events.add('click', function (e) {
        const coords = e.get('coords');
        const label = prompt("Введите подпись для точки:", "Точка: " + coords);
        if (label !== null) {
          createPlacemark(coords, label);
          savePlacemarks();
        }
      });
    });

ЛКМ по карте:

Получаем координаты
Запрашиваем у пользователя подпись (prompt)
Создаём метку и сохраняем
    function createPlacemark(coords, label) {
      const placemark = new ymaps.Placemark(coords, {
        balloonContent: label
      }, {
        preset: 'islands#redDotIcon',
        draggable: false
      });

Создание новой метки:

coords — координаты точки
label — подпись, отображается в балуне
Стиль: красная точка, нельзя перетаскивать
      // ПКМ по метке — удалить
      placemark.events.add('contextmenu', function () {
        map.geoObjects.remove(placemark);
        placemarks = placemarks.filter(p => p !== placemark);
        savePlacemarks();
      });

Если нажали ПКМ по метке:

Удаляем её с карты
Убираем из массива
Обновляем сохранение
      map.geoObjects.add(placemark);
      placemarks.push(placemark);
    }
Добавляем метку на карту и в массив.

    function savePlacemarks() {
      const data = placemarks.map(pm => ({
        coords: pm.geometry.getCoordinates(),
        label: pm.properties.get("balloonContent")
      }));
      localStorage.setItem("placemarks", JSON.stringify(data));
    }

🔹 Сохраняем все метки в localStorage:

Только координаты и подпись
Сериализуем в JSON
    function downloadPlacemarks() {
      const data = placemarks.map(pm => ({
        coords: pm.geometry.getCoordinates(),
        label: pm.properties.get("balloonContent")
      }));
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "placemarks.json";
      a.click();
      URL.revokeObjectURL(url);
    }

🔹 Сохраняем метки в .json файл:

Формируем JSON
Создаём Blob
Имитируем клик по ссылке для скачивания
Автоматически скачивается файл placemarks.json
    function loadPlacemarks() {
      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const data = JSON.parse(e.target.result);
          data.forEach(pm => createPlacemark(pm.coords, pm.label));
          savePlacemarks();
        } catch (err) {
          alert("Ошибка при загрузке файла");
        }
      };
      reader.readAsText(file);
    }
  </script>
</body>
</html>

🔹 Загружаем .json файл с метками:

Пользователь выбирает файл вручную
Читаем содержимое
Создаём метки
Сохраняем их в localStorage (на всякий случай дублирую сохранение)


# Работа с изображениями (фото в карточках)

**Данный код работает везде, где используются фотографии**

//ФаксимилеПодписиНажатие (название забыл пофиксить, тоже изменим)
Клиентская асинхронная процедура.
Открывает диалог выбора изображения (JPG, PNG, BMP), загружает файл на сервер, сохраняет его как присоединённый файл через СоздатьПрисоединенныйФайл, сохраняет ссылку на файл в поле Объект.ФайлКартинки.
Также обновляет визуальные переменные Плашка1, Плашка2, Плашка3 — используются для отображения последних загруженных изображений на форме.

//СоздатьПрисоединенныйФайл
Серверная функция без контекста.
Создаёт новый элемент справочника ОбъектыПрисоединенныеФайлы. Содержимое файла берётся из временного хранилища и сохраняется в поле ДанныеФайла. Устанавливаются свойства: владелец (физлицо), имя, расширение, размер, имя файла без расширения. Объект записывается и возвращается ссылка.

//ПолучитьДанныеКартинки
Серверная функция без контекста.
Получает объект файла по ссылке (ФайлКартинки) из справочника. Извлекает все нужные данные: имя, расширение, размер и само содержимое файла. Данные передаются в структуре. Содержимое файла помещается во временное хранилище и потом отображается на форме.

//ПоказатьКартинку
Клиентская асинхронная процедура.
Запрашивает данные картинки через ПолучитьДанныеКартинки, сохраняет файл во временную папку и открывает его во внешнем приложении.

//УдалитьИзображение
Клиентская процедура.
Удаляет картинку из объекта: вызывает ПометитьНаУдалениеПрисоединенныйФайл, очищает поле ФайлКартинки и переменные отображения изображения (Плашка1, ФайлФото).

//ПометитьНаУдалениеПрисоединенныйФайл
Серверная процедура без контекста.
Получает объект присоединённого файла по ссылке, устанавливает пометку удаления и записывает изменения.

ПриЧтенииНаСервере
Серверная процедура.
При открытии объекта обновляет переменные Плашка1, Плашка2, Плашка3, устанавливая в них ссылку на файл с изображением. Используется для отображения изображения на форме при загрузке.

ПередЗаписью
Клиентская процедура.
Формирует сокращённую запись ФИО (в формате "Фамилия И.О." или "Фамилия И.") и записывает её в поле Адрес, если строка Наименование не заканчивается на точку (помню рассказывал, чтоб после перезаписи у тебя не сокращались Имя Отчество постоянно).

ПередЗаписьюНаСервере
Серверная процедура.
Устанавливает текущего пользователя как автора объекта при сохранении.

**API - ЗаписьНовогоКлиента**

Данная обработка позволяет вытягивать из API данные, которые автоматически можно записать и создать нового пользователя. Удобно это будет при работе с сайтом, когда происходит заведение учётки на каком-либо сайте - создаётся новый клиент/пользователь в 1С. Обработка сделана для демонстрации работы, так как используется бесплатный API.

Код находится в обработке на форме. Комментарии находятся в модуле формы

# Вкратце о подсистемах

Впринципе название подсистем отражает их полную суть. Каждая подсистема связана с типом объектов префектур для управленческой деятельности в каждой из них.

**УправлениеПрефектурой**

Здесь, исходя из названия, происходит управление всеми объектами префектуры, сделано это для менеджеров в администрации района/префектуры, чтобы следить за актуальным состоянием 
различных объектов и учреждений во всей префектуре

**УправлениеИМенеджмент**

Здесь похожий с управлением префектурой функционал и назначение (те же функции), но направлены на управление уже из администрации Мэрии города


# РОЛИ

**АдминистраторСистемы**
Управляет системой, настраивает доступы, обеспечивает работоспособность.

**Библиотекарь**
Заведует библиотечными ресурсами, выдаёт материалы, ведёт учёт.
У него есть доступ к подсистеме Библиотеки и всем функционалом, что с подсистемой связан

**ITСпециалист**
Обеспечивает техническую поддержку, обслуживает оборудование и ПО.
Имеет доступ только к функционалу взаимодействия с оборудованием

**Бухгалтер**
Ведёт финансовый учёт, отчёты, начисляет зарплаты.
Имеет доступ к УправлениюПрефектурами, и зависит от того, в какой организации находятся сотрудники его учреждения

**Директор**
Директор школы. 
Имеет доступ к префектурам школы

**ДиректорДШ**
Директор детской школы, курирует учебный процесс.
Имеет доступ к дошкольным учреждениям

**Декан**
Руководит факультетом в вузе, отвечает за образование и дисциплину.
Доступ к ВысшимУчебнымЗаведениям


**ГлавВрач**
Управляет медицинским учреждением, контролирует качество услуг.
Доступ к поликлиникам и больницам

**ДеканСС**
Декан среднего специального учебного заведения (колледжа, техникума)
Имеет также доступ к ВысшимУчебнымЗаведениям


# О РАЗРАБОТКЕ МОДУЛЕЙ

**Модуль карт**

Для корректного отображения и мониторинга объектов было решено сделать возможность администраторам и пользователям базы 1С смотреть непосредственно на карте, где находится нужное учреждение и как до него добраться (сноска - тебе предлагаю показать ещё и старую версию, которую мы выгрузили внешней обработкой. Она неплохая, если заведется у них - заебись, там можно строить маршруты)

Сами карты используют бесплатный предоставляемый функционал Yandex API Maps, версии 2.1. При выборе я руководствовался актуальностью решения, а также возможностью грамотной интеграции данных карт с 1С

Сами карты представлены в виде HTMLПоля на форме обработки, а благодаря функционалу 1С, внутри я интегрировал HTML и JavaScript-код, который вызывается при запуске обработки пользователем, формирует соединение с картами и позволяет отображать карты и метки, а также создавать/удалять и давать наименования им

Метки можно сохранять в формате JSON и загружать при перезапуске (потому что 1С тяжело интегрирует данный функционал засчёт устаревшего браузерного движка, который он использует (там в 1С ваще древний интернет эксплорер)

**Модуль быстрого доступа к ресурсам**

Модуль быстрого доступа к ресурсы был создан для того, чтобы пользователи могли максимально быстро добраться до необходимого им ресурса, не выходя из 1С и иметь возможность отслеживать актуальные данные и изменения в работе учреждений

Для этого работает механизм HTTPсоединения и OpenSSL, которое выстраивает защищенное веб-соединение между сайтом-ресурсом и базой 1С и позволяет открыть веб-сайт непосредственно через HTMLПоле на форме 1С.

**Модуль API - ЗаписьНовогоКлиента**

О разработке:
Для того, что настроить взаимодействие в реальном времени между пользовательскими интерфейсами разных учреждений (сайты, приложения) и базой 1С решено было написать интегрирующее звено между ними. Данное звено позволяло вытягивать нужные данные нового пользователя/клиента с сайта и записывать нового клиента в 1С.

Было принято решение использовать бесплатный API от Ninja.com, который отправляет JSON ответ со случайно сгенерированными контактными данными и ФИО пользователя.
Разработка подключается по HTTPЗапросу и используя сгенерированный API ключ и встроенный функционал обработки и чтения JSON-файлов, который предоставляет 1С, после запроса происходит обработка полученного JSON-ответа и преобразуется в Структуру, из которой заполняется новый пользователь по соответствию полей.

**Модуль отслеживания периферии**

Для корректного отслеживания того, какое оборудование поступало и используется на объектах было принято решение создать централизованную обработку, которая отслеживает работу компьютеров на всех объектах, а также то, какие пользователи их используют и когда, благодаря механизму, который задействует динамические списки, что позволяет отслеживать работу на компьютерах в режиме реального времени

При создании документа об использовании ПК автоматически создается запись в регистр и отслеживается время начала работы и какой пользователь сел за компьютер. После завершения работы запись в динамическом списке исчезает и документ автоматически закрывается. Все это можно отслеживать и взаимодействовать в интерфейсе обработки ИспользованиеПК


-----------------OLD VERSIONS------------------

---ver. 0.5---
--patch-list--
Текущая версия имеет на 80% законченый интерфейс, из плана доработок: цветовая схема, иконки подсистем, иконки при записях (в динамических списках)

  Изменения:
  1. Фотографии к справочнику сотрудники
  2. Рефактор сотрудников (изменена форма, адаптирована под подсистемы)
  3. Переработаны подсистемы, модель разграничения прав в разработке, каркас пуст, но готов к работе
  4. Парсинг страницы с картами (можно адаптировать как фишку для быстрого поиска местонахождения нужного предприятия/потенциально реализовать фишку с отметками на карте)
  5. Начата работа над динамическими обработками (алгоритм в работе, к следующему коммиту будет первый результат. Предназначены для пробок и ДТП)
  6. Переработанны фотографии. Новый код привязан к объектам города (территориальные карточки мест считай на 80% готовы)
  7. Интеграция с картами по API (пока что в процессе работы)
  8. Сформированы документы, справочники, иерархия (готово на 70%, необходимо адаптировать некоторые документы и связать их логически)
  9. Готов макет дополнительной навигации
  10. Доработано разграничение прав

      
Сноска:
Дальнейшая работа будет направлена на базовые функции (ориентировочно 17 мая). Будет настроен учет важного оборудования для каждого объекта. Силы будут сконцентрированы на завершение навигации и цветовой схеме, а также иконках. Потенциально есть шанс успеть к коммиту 17 мая доделать интеграцию карт с 1С.

--patch-list--
---ver. 0.5---
