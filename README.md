# Управление и мониторинг инфраструктуры

-----------ACTUAL VERSION (0.9.5)-------------

Техническая документация:

**Работа с регистрами накопления**

Классическая методика записи данных в регистры накопления

В документах используется стандартный механизм записи данных в регистры сведений через таблицу движений (когда ты привязываешь регистратор/документ к регистру накопления). Этот механизм настраивается в конфигураторе через свойства документа — на вкладке "Движения" указывается, в какие регистры и по каким правилам записываются данные.
Сам код записи в регистры автоматически формируется при проведении документа на основании этих настроек.

**Обработка Веб-страниц**

Процедуры вызываются на клиенте и предназначена для открытия сайтов через встроенную обработку. В объекте устанавливается признак выбранного действия (к примеру "ГАИ" и URL "https://госавтоинспекция.рф"). Далее выбранное значение записывается в объект, создаётся структура параметров с этим адресом и оповещение "Реадресация", которое, обрабатывается внутри формы. Затем открывается форма обработки Обработка.ДоступКСайтам.Форма.Форма, куда передаётся URL (Параметры.ВебСтраница. По сути после закрытия формы выбранное значение сохраняется в реквизит и при открытии формы с веб-страницей уже автоматически тянется нужный URL).

**Обработка управление модулями**

Тут, думаю, всё предельно ясно, обычная реадресация, при нажатии кнопки открывает другую форму (работает примерно по тому же принципу что и предыдущая, но вместо URL перенаправляет на нужные формы в 1С)

**Обработка управление префектурами**

Тут частично механизм из Веб-страниц (поймешь при нажатии) и динамические списки (по сути те же самые запросы как в отчетах просто в реальном времени, чтоб посмотреть какой там код открываешь вот здесь (ПКМ по динамическому списку -> Свойства -> Настройки списка)

<img width="1151" alt="Снимок экрана 2025-06-06 в 03 49 22" src="https://github.com/user-attachments/assets/736f1b50-d51d-4db8-8c91-ef18a0b9246d"/>


**Обработка реадресация** 

Обычная отдельная обработка чтоб удобнее было заниматься навигацией (тоже покликаешь поймешь, работает в паре с управлением модулями)

**Работа с картой и маршрутами**

Вот тут самое интересное, пытался объяснить вместе с нейросетью и гайдами на ютубе, думаю если спросят - ужать это ты сможешь. 

//ПриСозданииНаСервере

Когда форма создаётся на сервере, вызывается процедура ИнициализироватьКарту(), которая подгружает HTML-шаблон карты и маркер, заменяет путь к изображению маркера на встроенные base64-данные и передаёт этот HTML в поле ПолеHTML, чтобы отобразить карту на форме.

//ПолеHTMLПриНажатии

При нажатии на карту (на HTML-элемент ПолеHTML), вызывается JS-функция getLastMarkerLocation(), которая возвращает координаты последнего щелчка. Если координаты получены, создаётся новая точка маршрута в структуре ТочкиМаршрута и сохраняется широта и долгота из полученных данных. То есть, при клике на карту ставится точка маршрута.

//ПостроитьМаршрут

Запускает JS-функцию buildRoute() внутри HTML-документа карты. Эта функция рассчитывает маршрут по уже добавленным точкам и отображает его на карте.

//ПолучитьИнформациюОМаршруте

Получает информацию о построенном маршруте из браузера через getRouteInfo(). Данные приходят в виде JSON. Затем вызывается процедура ПрочитатьИнформациюОМаршрутеИзJSON(), которая парсит JSON, достаёт общее время и длину маршрута, а также список пошаговых инструкций (дороги и тексты) и заполняет соответствующую структуру Инструкции.

//ОчиститьМаршрут

Полностью очищает текущий маршрут: удаляет точки маршрута (ТочкиМаршрута.Очистить()), пошаговые инструкции (Инструкции.Очистить()), обнуляет значения времени и расстояния. В интерфейсе удаляет маркеры и сам маршрут с карты через JS-функции removeAllMarkers() и removeRouting().

//ИнициализироватьКарту

На сервере загружается HTML-шаблон карты и картинка маркера. Изображение маркера кодируется в base64 с помощью ДвоичныеДанныеВBase64, заменяется путь к marker.png на встроенные base64-данные, и результат сохраняется в ПолеHTML, чтобы отобразить карту с нужным маркером прямо в форме без обращения к внешнему файлу.

//ДвоичныеДанныеВBase64

Преобразует бинарные данные изображения в строку base64 и очищает её от символов переноса строки, чтобы можно было безопасно вставить в HTML.

//ПрочитатьИнформациюОМаршрутеИзJSON

Разбирает JSON-строку с маршрутом, достаёт из неё общее время и расстояние, очищает список инструкций и заново его заполняет. Каждая инструкция содержит название улицы и текст подсказки.

//ПолучитьЗначениеИзJSON

Создаёт объект ЧтениеJSON, устанавливает в него входную строку JSON и вызывает встроенную функцию ПрочитатьJSON(), которая возвращает структуру данных.

       **А тут уже JS играется**

Сам JS-код вместе с HTML находится в Макетах. Код лежит ТОЛЬКО в шаблоне карты, двоичные данные нужны для записи координат точек:

- Шаблон карты (отрисовка самой карты)

  Инициализация карты:
const map = L.map("map", { attributionControl: false }).setView(
  [52.0317, 113.501],
  13
);
Создает карту с центром на координатах [52.0317, 113.501], масштаб 13 (думаю поправлю на Москву, а то чет я хуйню написал и у нас там нихуёвая Чита).

Добавление тайлов (плиток):
const tiles = L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 19,
}).addTo(map);
Загружает OpenStreetMap-плитки как подложку карты (по сути реально отображает тайлы благодаря Leaflet).

Маркеры и маршруты
Переменные:

let routingControl;
let markers = [];
let distance = 0;
let time = 0;
let instructions;
routingControl — объект маршрута.
markers — список маркеров.
distance, time, instructions — информация о маршруте.
Иконка маркера:

const markerIcon = new L.DivIcon({
  className: "marker",
  html: `<img src="marker.png" style="width:20px; height: 20px"/>`,
  iconSize: [35, 35],
});
Создает кастомный маркер в виде иконки с marker.png (если хочешь поиграться - попробуй сменить).

Обработка клика по карте:
map.on("click", onMapClick);

function onMapClick(e) {
  addMarker(e.latlng);
}
Добавляет обработчик на клик по карте, вызывающий addMarker (отвечает за появление маркеров на мапе).

Функция добавления маркера:
function addMarker(latlng) {
  if (routingControl) return; // Если уже построен маршрут — не добавлять
  const marker = L.marker(latlng, { icon: markerIcon }).addTo(map);
  map.panTo(marker.getLatLng()); // Центрировать карту на маркере
  markers.push(marker);
}
Построение маршрута:
function buildRoute() {
  routingControl = L.Routing.control({
    waypoints: markers.map((marker) => marker.getLatLng()),
    routeWhileDragging: true,
    createMarker: function () {
      return null; // Не создавать стандартные маркеры
    },
    language: "ru",
    lineOptions: {
      styles: [{ color: "#5158bb", opacity: 1, weight: 5 }],
    },
  }).addTo(map);

  routingControl.on("routesfound", function (e) {
    distance = e.routes[0].summary.totalDistance;
    time = e.routes[0].summary.totalTime;
    instructions = e.routes[0].instructions;
  });
}
Строит маршрут между маркерами.
Сохраняет:
distance — расстояние в метрах.
time — время в секундах.
instructions — массив текстовых шагов маршрута.
Получение последнего маркера (при нажатии когда формируешь маршрут):
function getLastMarkerLocation() {
  if (markers.length === 0) return null;
  const latlng = markers[markers.length - 1].getLatLng();
  return [latlng.lat, latlng.lng];
}
Получение JSON-информации о маршруте:
function getRouteInfo() {
  return JSON.stringify({
    distance,
    time,
    instructions,
  });
}
Удаление маршрута:
function removeRouting() {
  if (routingControl) {
    map.removeControl(routingControl);
    routingControl = undefined;
    distance = 0;
    time = 0;
    instructions = undefined;
  }
}
Удаление всех маркеров:
function removeAllMarkers() {
  for (i = 0; i < markers.length; i++) {
    map.removeLayer(markers[i]);
  }
  markers = [];
}

**Работа с изображениями (фото в карточках)**

//ФаксимилеПодписиНажатие (название забыл пофиксить, тоже изменим)
Клиентская асинхронная процедура.
Открывает диалог выбора изображения (JPG, PNG, BMP), загружает файл на сервер, сохраняет его как присоединённый файл через СоздатьПрисоединенныйФайл, сохраняет ссылку на файл в поле Объект.ФайлКартинки.
Также обновляет визуальные переменные Плашка1, Плашка2, Плашка3 — используются для отображения последних загруженных изображений на форме.

//СоздатьПрисоединенныйФайл
Серверная функция без контекста.
Создаёт новый элемент справочника ОбъектыПрисоединенныеФайлы. Содержимое файла берётся из временного хранилища и сохраняется в поле ДанныеФайла. Устанавливаются свойства: владелец (физлицо), имя, расширение, размер, имя файла без расширения. Объект записывается и возвращается ссылка.

//ПолучитьДанныеКартинки
Серверная функция без контекста.
Получает объект файла по ссылке (ФайлКартинки) из справочника. Извлекает все нужные данные: имя, расширение, размер и само содержимое файла. Данные передаются в структуре. Содержимое файла помещается во временное хранилище и потом отображается на форме.

//ПоказатьКартинку
Клиентская асинхронная процедура.
Запрашивает данные картинки через ПолучитьДанныеКартинки, сохраняет файл во временную папку и открывает его во внешнем приложении.

//УдалитьИзображение
Клиентская процедура.
Удаляет картинку из объекта: вызывает ПометитьНаУдалениеПрисоединенныйФайл, очищает поле ФайлКартинки и переменные отображения изображения (Плашка1, ФайлФото).

//ПометитьНаУдалениеПрисоединенныйФайл
Серверная процедура без контекста.
Получает объект присоединённого файла по ссылке, устанавливает пометку удаления и записывает изменения.

ПриЧтенииНаСервере
Серверная процедура.
При открытии объекта обновляет переменные Плашка1, Плашка2, Плашка3, устанавливая в них ссылку на файл с изображением. Используется для отображения изображения на форме при загрузке.

ПередЗаписью
Клиентская процедура.
Формирует сокращённую запись ФИО (в формате "Фамилия И.О." или "Фамилия И.") и записывает её в поле Адрес, если строка Наименование не заканчивается на точку (помню рассказывал, чтоб после перезаписи у тебя не сокращались Имя Отчество постоянно).

ПередЗаписьюНаСервере
Серверная процедура.
Устанавливает текущего пользователя как автора объекта при сохранении.

**Классическая структура**

Сама структура базы очень простая, есть документы, они связаны с регистрами для учёта (регистры накопления) и их можно где-то посмотреть (в журнале документов или отчётах)

**API и TG-Bot**

--WIP--


-----------------OLD VERSIONS------------------

---ver. 0.5---
--patch-list--
Текущая версия имеет на 80% законченый интерфейс, из плана доработок: цветовая схема, иконки подсистем, иконки при записях (в динамических списках)

  Изменения:
  1. Фотографии к справочнику сотрудники
  2. Рефактор сотрудников (изменена форма, адаптирована под подсистемы)
  3. Переработаны подсистемы, модель разграничения прав в разработке, каркас пуст, но готов к работе
  4. Парсинг страницы с картами (можно адаптировать как фишку для быстрого поиска местонахождения нужного предприятия/потенциально реализовать фишку с отметками на карте)
  5. Начата работа над динамическими обработками (алгоритм в работе, к следующему коммиту будет первый результат. Предназначены для пробок и ДТП)
  6. Переработанны фотографии. Новый код привязан к объектам города (территориальные карточки мест считай на 80% готовы)
  7. Интеграция с картами по API (пока что в процессе работы)
  8. Сформированы документы, справочники, иерархия (готово на 70%, необходимо адаптировать некоторые документы и связать их логически)
  9. Готов макет дополнительной навигации
  10. Доработано разграничение прав

      
Сноска:
Дальнейшая работа будет направлена на базовые функции (ориентировочно 17 мая). Будет настроен учет важного оборудования для каждого объекта. Силы будут сконцентрированы на завершение навигации и цветовой схеме, а также иконках. Потенциально есть шанс успеть к коммиту 17 мая доделать интеграцию карт с 1С.

--patch-list--
---ver. 0.5---
